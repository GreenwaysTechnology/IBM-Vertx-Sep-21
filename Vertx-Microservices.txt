				Vertx -Micro services Implemenations
.
.............................................................................................

				Micro Services Implementation Using Vertx
..............................................................................................

Application Types

1.System softwares- OS,Device related application
2.Application softwares- to solve real world problems - banking,insurance,retail...

How to develop application software?

-Programming language - java
   -Lib,Frameworks,toolkits

Any application has two things

-Application code

-Datasource-Database/filesystem/inmemory.

Any application is designed based on some arch.

-main frame based
-client server 
  -single
  -two tier
  -there tier
  -n-tier
tier -layer

-User interface
-back end 
   -service 
   -data layer

Banking:
 -java language- Spring Framework

Web application-Restfull architecture-based on Rest spec.

-Spring MVC
.........................................................................................
                                          Distributed Application
..........................................................................................

1.Monolithic

Apps in java :

 in dev we write code,compile code,run time.

how to handover application to customer - packing

 java apps are packed
   -jar
   -war
   -ear

data.jar
util.jar
banking.war

...........................................................................................

Deployment procesS:

  putting war/ear on web servers
...........................................................................................

Customers/users will access the application using urls -http://www.examplebank.com/

..........................................................................................


1.Monollithic Application Development Steps

Properties:

1.Domain - Biz requirement  - Domain Analyist - Collecting Requirement

2.Requirement into Software Specification

Technology:
 Java-JEE

 -Framework -Spring
 -Database - MYsql
 -Middlewares -  RabbitMQ....
 -Dev Server -Tomcat
 -DeploymentServer - JBoss  

3.High Level Design
   Data Modeling
   JEE App Design
    -Web layer ,entity layer,messaging layer


4.Development
    Provisions for dev

5.Testing 
    

6.Production Plan.


Monolithic app work flow will go one by one 


Cons of Monolithic:

1.Requirement can t be freezed in short duration, since biz is dynamic.

2.Tech stack:
  There are many modules in the app, any one of the module need to be development in different
 Technology
  -python,nodejs,Ruby,C#
  -different databases -  sql, nosql,messaging servers

 Vendor-lock

3.Design can be started once req is freezed
  -we have many modules, most of the modules are over, payment module taking much time to freeze.

4.Dev
   Dev cant be started due to req not clear.

5.Test 
   until over testing cant be

6.Deployment - Production
   -The whole app must be ready for deployment.
   -Provisioning
      -database,webservers,middlewares....
..............................................................................................
					Micro Services:

Common ideas

1.Highly maintainable and testable
2.Loosely coupled
3.Independently deployable
4.Organized around business capabilities
5.Owned by a small team


Advantages:

Strong Module Boundaries: Microservices reinforce modular structure, which is particularly
important for larger teams.

• Independent Deployment: Simple services are easier to deploy, and since they are autonomous,
are less likely to cause system failures when they go wrong.

• Technology Diversity: You can mix multiple languages, development frameworks and datastorage
technologies (i.e. each team working on a microservice has more flexibility to employ
different technologies without affecting other teams).
  

Cons of Micro Services:
.......................

• Distribution: Distributed systems are harder to program since remote calls are slow and are
always at risk of failure.
• Eventual Consistency: Maintaining strong consistency is extremely difficult for a distributed system, which means everyone has to manage eventual consistency.
• Operational Complexity: You need a mature operations team to manage lots of services which
are being redeployed regularly.
.............................................................................................

.............................................................................................
                               Distributed Application Design Patterns
.............................................................................................

Distributed Application Design Pattern: 
-Monolithic
-MicroServices
.............................................................................................
                            Monoloith Design patterns 
.............................................................................................

1.GOF patterns
2.JEE Patterns
   -MVC
   -DAO
   -Service Locator

..............................................................................................
	        Microservices Application Design Patterns
.............................................................................................
Monolith to Micro services:
...........................
Cube Model to scale app

-Functional Decomposition : DDD model- 
   Microservices are subdomain driven model. 


Data Layer-(Data Management) Design patterns In Microservices:
............................................
1.Database per Service
2.Shared database
3.Saga
4.API Composition
5.CQRS
6.Domain event
7.Event sourcing
...........................................................................................  

		Application Development and its Related Patterns:
...........................................................................................

-Language ----Framework /Lib
-Java:
Style:
  -Object Oriented Programming language
  -Functional Style Programming 

OOP :
 -Object
   -State + Behaviour

What is Service?
  Service is nothing but "offer".
  The Object which offer some features

  OrderService offers order related Features
  -placeOrder
  -findAllOrders
  -findOrderByid
  -updateExistingOrder
  -cancelOrder
  -etc....
What is Micro?
   Smallest 

What is Micro Service?
   Smallest Service in   a domain

Is there is any pattern is avaible to design Service?

Based on SOLID Prinicples

1.Single Responsibility Principle
2.Open/Closed Principle
3.Liskov Substitution Principle
4.Interface Segregation Principle
5.Dependency Inversion

Every service need to designed based on 

 "Single Responsibility Principle" - SRP

How to Represent Service?

 Every Service is Object.

class CreditCardService {

}
class DebitCardService {

}
............................................................................................
				Object (Service) Communication:
.............................................................................................
Service Communication style Design Pattern

1.Remote Procedure Invocation
2.Messaging
3.Domain-specific protocol
4.Idempotent Consumer
...........................................................................................
				Service Communication and failures

Distributed Services are subject to fail,slow.

Eg:

 Service-A calls Service-B --may call external systems like db,apis,message middlewares.

Service-B may fail due to various reasons
   -Network failure
   -Latancy issues
   -Exceptions and Errors

Because of One Service Failure
The entire system should not fail.
..............................................................................................
                           Micro Service Design pattern to handle failures
			           (Realiability Patterns)
.............................................................................................

Incase failure happens, Reality Patterns gives alternate solution to the caller(clients).

1.CircuitBreaker
2.BulkHead
3.ReateLimiter
4.Retry
5.TimeLimiter
6.Fallbacks using cache
..............................................................................................
				   Service Identification and Communication
..............................................................................................
				
If services are talking each other in network we need to know

-location of the service and port address of the service.

incase if services are running containers and cloud env, where ip address is dynamic, how services can collabrate using ip address/dns names.
.............................................................................................
			      Service Registry and Discovery Patterns
...............................................................................................

What is Service Registry?
   
   Middleware where services are registered before access them.  

Service Registries are third party softwares

1.Apache Zookeeper
2.Consul
3.Netflix eureka
4.Redis
etc......

Why Service Registry?

-Where are services are hosted in dynamic virtualized or containerized env where we cant identify the service instances.

What is Discovery ? 
  Looking up/Search services from Service Registry
............................................................................................
  		          Scalability and High Availablity
............................................................................................

What if i want to run the same instance multiple copies?
 This is called horizintal scaling 

When we scale apps, we need to indentifiy which instance will be served to the caller service.

Load Balancer  is component which takes cares of selecting right instance based on algorthims provided by load balancer.

Algorthims may be round robin,random,cpu usage based,sharding , latency based.
..............................................................................................
			     How to deploy microservices in production
				     Deployment Patterns
..............................................................................................

1.Multiple services per host.
2.Single Service instance per host
3.Service instance per vm
4.Service instance per container
5.Servless Deployment
6.Service Deployment Platforms
..............................................................................................
				 Development and Production Common things

1.Configuration:
   How to configure application properties
   -Settings
      db
      web
      security
      app dynamic parameters

We can maintain externalized / distribtued configuration system - Centeralized Configuration
information
 -database
 -mailing
 -registry
 -payment gate
 -passwords/ walets

It can a server.
 -ldap
 -kubernets - config map
 -apache zookeeper

What ever key value server.
.............................................................................................
				Maintaince/Management patterns
............................................................................................
Monitoring /Managing Patterns:
..............................

1.Logging
  Logs with in Services

Log Types:
-Console Logs
-File Based logs
-Database logs

				How to log centeralized and anaylis

1.ELK
2.Graylog
3.EFK
4.Sys logs
..............................................................................................
					Mertics

Perfomance Management:

How to measure microservices performance?

Memory,Process,threads....

1.Prometheus
2.DataDog
3.MicroMeter
..............................................................................................
				  Tracing
		
How to trace service calls?
 service to service call duration,response time.

1.Zipkin
2.Jaeger
.............................................................................................
				Health Patterns and Tools
............................................................................................

Health of
-database
-web end points
-message server health

1.Prometheus
2.actuator 
..............................................................................................
				 External API GateWay

Api Gate way can be used for connecting microservices in and outside world.

Api gateways

1.apigee way
2.aws
3.Netfilx api gateway
4.Nginx
.............................................................................................
			          Micro Services Security
............................................................................................

Authentication and authorization

In micro servies and gateways patterns, microservices consist of numerous services.
The api gate way is the single entry point for client request.
It authenticate requests, and forwards them to other services, which might in turn invoke other services

In monlith systems, auth implemented via "Session Tokens" -  userid and password is exchanged
via "cookie" header.
............................................................................................
				Implementation : JSON Web Token
............................................................................................

JWT is also token based pattern like "session Tokens" , where session tokens are very usefull only if the application is hosted in single server.

Since session token cant be used to track apps running in different process. so we can use 
JWT , Sticky Session from api gateway.
.............................................................................................
   		 Micro Service Pattern/Architecture Implementation
............................................................................................

Microservies can be implemented on any platform(os), on language - Platform,language indepand.

Micro service implmentions On JVM:
..................................

1.Spring Framework provides an Project - Spring Cloud
2.Quarkus Framework provides an project - MicroProfile ---SmallRye
3.Ecplise Vertx
4.MicroNaut - written in Kotlin
5.Light4J
etc.......
..............................................................................................
				 How to represent services in vertx
..............................................................................................

1.HTTP based service
   RESTFull Service
2.rpc service 

3.graphql

.............................................................................................
				Restfull Web Developement in vertx
.............................................................................................


Core features of vertx web development

-it is non blocking - min number of threads are used- there is no request per thread model.
-it is reactive, so that data streaming ,processing is possible.

Web App development in vertx:

Vertx is fully powered with non blocking apis.
Vertx supports http prototcal to build non blocking web apps.

Modules In web space:

1.vertx core http module.
2.vertx-web module - It is minialistic framework to build realtime Webservices and dynamic web apps
3.vertx-webclient -  Service interaction api via  http Protocal



HTTP Core module Object:

1.HttpServer
   -Used to build web containers
   -Used to handle incomming request and sending response.
2.HttpServerRequest
   -Object used to handle incoming request
   -has api called response() to get Resonse Object
3.HttpServerResponse
   -Object used to send resonse to clients


package com.ibm.microservice.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerResponse;

public class MainVerticle extends AbstractVerticle {

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    //create server instance
    HttpServer httpServer = vertx.createHttpServer();
    //request Handle
    httpServer.requestHandler(httpServerRequest -> {
      HttpServerResponse response = httpServerRequest.response();
      response.end("Hello");
    });
    //start server
    httpServer.listen(8080, server -> {
      System.out.println("Http Server is running on --> " + server.result().actualPort());
    });

  }
}
...........................................................................................
				Fluent style api
............................................................................................
    vertx.createHttpServer()
      .requestHandler(httpServerRequest -> {
        httpServerRequest.response().end("Hello");
      }).listen(8080, server -> {
        System.out.println("Http Server is running on --> " + server.result().actualPort());
      });
............................................................................................
			Properties of Http Response

-header
-statuscode
  vertx.createHttpServer()
      .requestHandler(httpServerRequest -> {
        httpServerRequest.response()
          .setStatusCode(200)
          .putHeader("content-type", "text/plain")
          .putHeader("message", "HelloHeader")
          .end("Hello");
      }).listen(8080, server -> {
        System.out.println("Http Server is running on --> " + server.result().actualPort());
      });
...........................................................................................
			     JSON DATA
...........................................................................................

In Vertx json is default data interchange format for sending data across the micro services.

Vertx Provides Builtin json parser Object.

JsonObject

How to create json object and send it to client?				

 JsonObject greeting = new JsonObject()
      .put("name", "Subramanian")
      .put("message", "Hello");

    JsonArray messages = new JsonArray()
      .add(greeting)
      .add(new JsonObject()
        .put("name", "Geetha")
        .put("message", "welcome"))
      .add(new JsonObject()
        .put("name", "Ram")
        .put("message", "How are you?")
        .put("location", "Coimbatore")
      );

    vertx.createHttpServer()
      .requestHandler(httpServerRequest -> {
        httpServerRequest.response()
          .setStatusCode(200)
          .putHeader("content-type", "application/json")
          .end(messages.encodePrettily());
      }).listen(8080, server -> {
        System.out.println("Http Server is running on --> " + server.result().actualPort());
      });
.............................................................................................
				How to handle client Requests\

Data Representation in Vertx
1.JsonObject
2.Buffer

Buffer:
.......
Most data is shuffled around inside Vert.x using buffers.

A buffer is a sequence of zero or more bytes that can read from or written to and which expands automatically as necessary to accommodate any bytes written to it. You can perhaps think of a buffer as smart byte array.

Buffer buff = Buffer.buffer();
Buffer buff = Buffer.buffer("some string");
 vertx.createHttpServer()
      .requestHandler(httpServerRequest -> {
        //in order to handle client payload
        httpServerRequest.bodyHandler(buffer -> {
          httpServerRequest
            .response()
            .end(buffer.toJsonObject().getString("message"));
        }).endHandler(handler -> {
          System.out.println("Request has been processed");
        });
      }).listen(8080, server -> {
        System.out.println("Http Server is running on --> " + server.result().actualPort());
      });
.............................................................................................
		//////////////////////////////////////////////////////////////////////////////////////////////
			   Are we building Realtime RESTFull Services
..............................................................................................
No!

Because RestFull webservies must have the following features

1.Resource - like CustomerResource,OrderResource,ProductResource.....


2.URI Mapping

 /api/customers
 /api/customers/1
 /api/customers/orders
 /api/customers/search/name

3.HTTP Method Mapping
  GET,POST,DELETE,PUT

Vertx-core http module cant be used to build realtime http based microservices



RoutingContext:
  It is eq to servletcontext in servlet 

 - used to get request and response objects.


package com.ibm.microservice.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.ext.web.Router;

public class GreeterRestApiVerticle extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    Router router = Router.router(vertx);

    //HTTP Method mapping
    //HTTP - GET Mapping
    router.get("/api/hello").handler(rc -> {
      //send response
      rc.response().setStatusCode(200).end("Hello");
    });
    router.get("/api/hai").handler(rc -> {
      //send response
      rc.response().setStatusCode(200).end("Hi");
    });
    router.get("/api/greet").handler(rc -> {
      //send response
      rc.response().setStatusCode(200).end("greet");
    });

    vertx.createHttpServer()
      .requestHandler(router)
      .listen(8080, server -> {
        System.out.println("Rest API Server is Running -->" + server.result().actualPort());
      });
  }
}
.....................................&&&&&&&&&&&&&&..........................................
				Vertx-Reactive Implmentation
.............................................................................................
  <dependency>
      <groupId>io.vertx</groupId>
      <artifactId>vertx-rx-java2</artifactId>
    </dependency>

Where we can use Reactive Extensions?

Any Where, data is moving


There are two context:

1.on application data?

 if you are sending data over api like findAllEmployees - list of employees

2.On existing vertx apis

Any io apis has two version

1.callback version
2.reactive version

  httpModule -  IO API
    vertx.createHttpServer().requestHandler(callback).listen()
   
   vertx.createServer().requestHandler(rxstream).listen();

AbstractVerticle has two versions

 -normal
 -Rxified Vert.x API enhancing the core Vert.x API
.............................................................................................
				Reactive WebServer
.............................................................................................


Why Reactive WebServer?

 -NonBlocking/Async
 -Streaming

package com.ibm.microservice.web.reactive;

import io.vertx.reactivex.core.AbstractVerticle;
import io.vertx.reactivex.ext.web.Router;

public class ReactiveWebServer extends AbstractVerticle {

  private void simpleReactive() {

    //web
    vertx.createHttpServer().requestHandler(rc -> {
//      HttpServerResponse response = rc.response();
      rc.response().end("Hello");
    }).rxListen(3000).subscribe(server -> {
      System.out.println("Reactive WebServer is running --->" + server.actualPort());
    }, err -> {
      System.out.println(err.getMessage());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    Router router = Router.router(vertx);
    router.get("/").handler(routingContext -> {
      routingContext.response().end("Reactive Router");
    });
    vertx.createHttpServer().requestHandler(router).rxListen(3000).subscribe(server -> {
      System.out.println("Reactive WebServer is running --->" + server.actualPort());
    }, err -> {
      System.out.println(err.getMessage());
    });

  }
}
............................................................................................
				 CURD Operations - Data Base
...........................................................................................

GET,POST,DELETE,PUT
............................................................................................

  In vertx web layer is non blocking, database layer can also be non blocking.

Vert only supports jdbc technology in non blocking way.
If i want to write jpa,hibernate, yes we can but which will be blocking way.

Non Blocking JDBC and Non blocking Web
......................................

Vert.x JDBC client:

This client allows you to interact with any JDBC compliant database using an asynchronous API from your Vert.x application.

The client API is represented with the interface 
JDBCClient
.

To use this project, add the following dependency to the dependencies section of your build descriptor:


SQL Client Templates
A small library designed to facilitate the execution and data manipulation of SQL queries
..............................................................................................
				Service

package com.ibm.microservice.web.jdbc;

import io.vertx.core.AsyncResult;
import io.vertx.core.Future;
import io.vertx.core.Handler;
import io.vertx.core.Vertx;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import io.vertx.jdbcclient.JDBCPool;
import io.vertx.sqlclient.RowSet;
import io.vertx.sqlclient.SqlResult;
import io.vertx.sqlclient.templates.SqlTemplate;
import io.vertx.sqlclient.templates.TupleMapper;

import java.util.Arrays;
import java.util.Map;

public class ProductService {
  //SQL Statements
  //CREATE TABLE
  String CRATE_TABLE = "CREATE TABLE IF NOT EXISTS products(id int IDENTITY, name VARCHAR(255), price FLOAT, weight INT)";
  //insert
  String insertQuery = "INSERT INTO  products(name,price,weight) VALUES (#{name},#{price},#{weight})";
  private Vertx vertx;
  //jdbc connection
  private JDBCPool client;
  //SqlTemplate api references
  private SqlTemplate<Map<String, Object>, RowSet<JsonObject>> getProductTemplate;
  private SqlTemplate<JsonObject, SqlResult<Void>> addProductTemplate;

  public ProductService(Vertx vertx) {
    this.vertx = vertx;
    init();
  }

  private void init() {
    //initlaize the connection
    client = JDBCPool.pool(this.vertx, new JsonObject()
      .put("url", "jdbc:hsqldb:mem:test?shutdown=true")
      .put("dirver_class", "org.hsqldb.jdbcDriver"));
    //Test Connection
    client.getConnection().onSuccess(System.out::println).onFailure(System.out::println);
    addProductTemplate = SqlTemplate.forUpdate(client, insertQuery).mapFrom(TupleMapper.jsonObject());

  }

  public Future createTable() {
    return client.query(CRATE_TABLE)
      .execute()
      .compose(res -> addProductTemplate.executeBatch(
        Arrays.asList(
          new JsonObject().put("name", "Tv").put("price", 10000).put("weight", 2),
          new JsonObject().put("name", "watch").put("price", 234).put("weight", 2),
          new JsonObject().put("name", "radio").put("price", 1000).put("weight", 2),
          new JsonObject().put("name", "computer").put("price", 345).put("weight", 2),
          new JsonObject().put("name", "tableandchair").put("price", 8999).put("weight", 2))));
  }

  public void findAllProducts(Handler<AsyncResult<String>> aHandler) {
    String selectProducts = "SELECT * From products";
    client.query(selectProducts)
      .execute(rowSet -> {
        if (rowSet.failed()) {
          //rc.fail(500);
          aHandler.handle(Future.failedFuture("500"));
        } else {
          JsonArray arr = new JsonArray();
          rowSet.result().forEach(row -> {
            arr.add(row.toJson());
          });
          aHandler.handle(Future.succeededFuture(arr.encodePrettily()));
        }
      });

  }


}
.............................................................................................
package com.ibm.microservice.web.jdbc;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpMethod;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.RoutingContext;
import io.vertx.ext.web.handler.BodyHandler;

public class ProductRestVerticle extends AbstractVerticle {
  private ProductService productService;

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start();
    productService = new ProductService(vertx);
    //1-connection-success-create tables-start web server
    productService.createTable().compose(v -> {
      //After inserting data : start web part
      Router router = Router.router(vertx);

      //Middlewares (filters) : Which are executed before handling requests

      //this middleware called for any type of request and any type of url
      router.route().handler(rc -> {
        System.out.println(rc.request().method() + " " + rc.request().path());
        rc.next();
      });
      //i want middleware sepecific to that url
      router.route(HttpMethod.GET, "/api/products").handler(rc -> {
        System.out.println("Products api called");
        rc.next();
      });
      //Builtin middlewares: BodyHandler is json seralizer which serialize the incoming json
      //payload into JsonObject
      router.route().handler(BodyHandler.create());

      //Rest apis
      //Get all the products from the database
      router.get("/api/products").handler(this::handleGetProducts);
      //create new product
      router.post("/api/products").handler(this::handleAddProducts);

      return vertx.createHttpServer().requestHandler(router).listen(8080, server -> {
        System.out.println("Product Service is Running " + server.result().actualPort());
      });
    });
  }

  private void handleAddProducts(RoutingContext routingContext) {

  }

  private void handleGetProducts(RoutingContext routingContext) {
    productService.findAllProducts(asyncResult -> {
      if (asyncResult.succeeded()) {
        routingContext.response()
          .setStatusCode(200)
          .putHeader("content-type", "application/json")
          .end(asyncResult.result());
      }
    });
  }
}
................

Add logic : YOu try Yourself.
private void handleAddProducts(RoutingContext rc) {
    HttpServerResponse response = rc.response();
    JsonObject product = rc.getBodyAsJson();
    addProductTemplate.execute(product)
      .onSuccess(res -> {
        response.setStatusCode(201).end("Created");
      }).onFailure(err -> {
        response.setStatusCode(500);
      });
  }
.............................................................................................
				   Service Communications
.............................................................................................

SERVICE Types

1.REST Service
2.Non Service
   -Event Bus

REST --HTTP- REST

REST--Event Bus (tcp)----NOnService


   

REST --- REST : WebClient

<dependency>
 <groupId>io.vertx</groupId>
 <artifactId>vertx-web-client</artifactId>
 <version>4.1.4</version>
</dependency>

.............................................................................................
				Service Communication : Micro services
.............................................................................................

Remote Procedure Invocation
Messaging
Domain-specific protocol
Idempotent Consumer
.............................................................................................
RPI : 
REST
gRPC
Apache Thrift
............................................................................................

REST
....
 The Services can talk each other via  http protocal.

How vertx implements HTTP communication?

Vert.x Web Client:
.................

Vert.x Web Client is an asynchronous HTTP and HTTP/2 client.

The Web Client makes easy to do HTTP request/response interactions with a web server, and provides advanced features like:


package com.ibm.microservice.rest.communication;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.buffer.Buffer;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.client.HttpResponse;
import io.vertx.ext.web.client.WebClient;

public class ProductGateWayVerticle extends AbstractVerticle {

  private WebClient webClient;

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    webClient = WebClient.create(vertx);
    Router router = Router.router(vertx);
    router.get("/api/products").handler(rc -> {
      //make request
      webClient.get(8080, "localhost", "/api/products")
        .send(ar -> {
          if (ar.succeeded()) {
            HttpResponse<Buffer> response = ar.result();
            rc.response().
              setStatusCode(200).
              putHeader("content-type", "application/json")
              .end(response.bodyAsString());
          } else {
            rc.response().setStatusCode(500).end(ar.cause().getMessage());
          }
        });
    });


    vertx.createHttpServer().requestHandler(router).listen(3000, server -> {
      int port = server.result().actualPort();
      System.out.println("APIGateWay is Running in ---" + port);
    });
  }
}
package com.ibm.microservice.web.jdbc;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpMethod;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.RoutingContext;
import io.vertx.ext.web.handler.BodyHandler;

public class ProductRestVerticle extends AbstractVerticle {
  private ProductService productService;

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start();
    productService = new ProductService(vertx);
    //1-connection-success-create tables-start web server
    productService.createTable().compose(v -> {
      //After inserting data : start web part
      Router router = Router.router(vertx);

      //Middlewares (filters) : Which are executed before handling requests

      //this middleware called for any type of request and any type of url
      router.route().handler(rc -> {
        System.out.println(rc.request().method() + " " + rc.request().path());
        rc.next();
      });
      //i want middleware sepecific to that url
      router.route(HttpMethod.GET, "/api/products").handler(rc -> {
        System.out.println("Products api called");
        rc.next();
      });
      //Builtin middlewares: BodyHandler is json seralizer which serialize the incoming json
      //payload into JsonObject
      router.route().handler(BodyHandler.create());

      //Rest apis
      //Get all the products from the database
      router.get("/api/products").handler(this::handleGetProducts);
      //create new product
      router.post("/api/products").handler(this::handleAddProducts);

      return vertx.createHttpServer().requestHandler(router).listen(8080);
    }).<Void>mapEmpty().onComplete(startPromise);
  }

//  <--Todo - ->
  private void handleAddProducts(RoutingContext routingContext) {

  }

  private void handleGetProducts(RoutingContext routingContext) {
    productService.findAllProducts(asyncResult -> {
      if (asyncResult.succeeded()) {
        routingContext.response()
          .setStatusCode(200)
          .putHeader("content-type", "application/json")
          .end(asyncResult.result());
      }
    });
  }
}
package com.ibm.microservice.web.jdbc;

import io.vertx.core.AsyncResult;
import io.vertx.core.Future;
import io.vertx.core.Handler;
import io.vertx.core.Vertx;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import io.vertx.jdbcclient.JDBCPool;
import io.vertx.sqlclient.RowSet;
import io.vertx.sqlclient.SqlResult;
import io.vertx.sqlclient.templates.SqlTemplate;
import io.vertx.sqlclient.templates.TupleMapper;

import java.util.Arrays;
import java.util.Map;

public class ProductService {
  //SQL Statements
  //CREATE TABLE
  String CRATE_TABLE = "CREATE TABLE IF NOT EXISTS products(id int IDENTITY, name VARCHAR(255), price FLOAT, weight INT)";
  //insert
  String insertQuery = "INSERT INTO  products(name,price,weight) VALUES (#{name},#{price},#{weight})";
  private Vertx vertx;
  //jdbc connection
  private JDBCPool client;
  //SqlTemplate api references
  private SqlTemplate<Map<String, Object>, RowSet<JsonObject>> getProductTemplate;
  private SqlTemplate<JsonObject, SqlResult<Void>> addProductTemplate;

  public ProductService(Vertx vertx) {
    this.vertx = vertx;
    init();
  }

  private void init() {
    //initlaize the connection
    client = JDBCPool.pool(this.vertx, new JsonObject()
      .put("url", "jdbc:hsqldb:mem:test?shutdown=true")
      .put("dirver_class", "org.hsqldb.jdbcDriver"));
    //Test Connection
    client.getConnection().onSuccess(System.out::println).onFailure(System.out::println);
    addProductTemplate = SqlTemplate.forUpdate(client, insertQuery).mapFrom(TupleMapper.jsonObject());

  }

  public Future createTable() {
    return client.query(CRATE_TABLE)
      .execute()
      .compose(res -> addProductTemplate.executeBatch(
        Arrays.asList(
          new JsonObject().put("name", "Tv").put("price", 10000).put("weight", 2),
          new JsonObject().put("name", "watch").put("price", 234).put("weight", 2),
          new JsonObject().put("name", "radio").put("price", 1000).put("weight", 2),
          new JsonObject().put("name", "computer").put("price", 345).put("weight", 2),
          new JsonObject().put("name", "tableandchair").put("price", 8999).put("weight", 2))));
  }

  public void findAllProducts(Handler<AsyncResult<String>> aHandler) {
    String selectProducts = "SELECT * From products";
    client.query(selectProducts)
      .execute(rowSet -> {
        if (rowSet.failed()) {
          //rc.fail(500);
          aHandler.handle(Future.failedFuture("500"));
        } else {
          JsonArray arr = new JsonArray();
          rowSet.result().forEach(row -> {
            arr.add(row.toJson());
          });
          aHandler.handle(Future.succeededFuture(arr.encodePrettily()));
        }
      });

  }


}
package com.ibm.microservices;

import io.vertx.core.Promise;
import io.vertx.reactivex.core.AbstractVerticle;

public class MainAppVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    vertx.rxDeployVerticle("com.ibm.microservice.web.jdbc.ProductRestVerticle").subscribe(r -> {
      System.out.println("ProductRestVerticle " + r + "deployed");
    }, err -> {
      System.out.println("ProductRestVerticle not deployed" + err.getMessage());
    });
    vertx.rxDeployVerticle("com.ibm.microservice.rest.communication.ProductGateWayVerticle").subscribe(r -> {
      System.out.println("ProductGateWayVerticle " + r + "deployed");
    }, err -> {
      System.out.println("ProductGateWayVerticle not deployed" + err.getMessage());
    });
  }

}
..............................................................................................				Service Communication -What if my service is not REST API	

					 EventBus
...........................................................................................


............................................................................................
				  Back End Services Communicaiton : EDA 
............................................................................................

EventBus:
  EventBus is used to enable service to service communication via events
..............................................................................................


1.message oriented style :Event Bus

Event Bus:

-Event Bus is nerve of vertx systems.

-Vertx By default is distributed

-Vertx carries distributed architecture by default

-In Vertx Verticles can communicate via Centraized Broker which is built in called event Bus.
-Event Bus uses tcp transport layer by default
-EventBus can send and recive data in the form of json and buffer


How verticle has been designed to adopt this architecture?

Verticle follows a design pattern  "Actor-like Model" ---->Actor Model design pattern


Event Bus:

1.Event Bus can allow verticles sends data from one place to another place
2.Event Bus forms a distributed peer-to-peer messaging system spannining multiple server nodes   and multiple browers.
3.Event bus allows sending messages in three ways
  1.pub/sub : one to many
  2.point-to-point : one to one
  3.request-reply(reponse) - one to one with acknowlegement.

4.Event bus identifies clients via "addressing"
   Messages are sent on the event bus to an "address"
   Address schemes can be any naming convention, recommendation is dns model "in.news.covid"
   
5.Handlers
   Since vertx is non blocking, messages are processed by handlers.
   You have to register a handler at an address

6.Type of Data
   Data type of message could be any primitive-int,char,boolean,String, Buffer,JSON

   Per Vertx Engine only One Event Bus-singleTon
..........................................................................................
			PUB-SUB,point to point,request-reply
............................................................................................

Three Verticles:

1.HTTP verticle- which will send messages to other verticles - back end verticles


package com.ibm.microservices;

public class Address {
  public static final String PRODUCT_INFO = "product.info";
  public static final String BILLING_INFO = "billing.info";
  public static final String IS_STOCK_AVAILABLE = "stock.available";


}

package com.ibm.microservice.backend.communication;

import com.ibm.microservices.Address;
import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.eventbus.EventBus;
import io.vertx.core.eventbus.MessageConsumer;
import io.vertx.core.json.JsonObject;


public class BillingVerticle extends AbstractVerticle {

  private void getProductInfo() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> consumer = eventBus.consumer(Address.PRODUCT_INFO);
    //list for message
    consumer.handler(message -> {
      System.out.println(BillingVerticle.class.getName() + "  -  " + message.body());
    });
  }

  private void getBillingInfo() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<JsonObject> consumer = eventBus.consumer(Address.BILLING_INFO);
    //list for message
    consumer.handler(message -> {
      System.out.println(BillingVerticle.class.getName() + "  -  " + message.body());
      //System.out.println(message.body().getInteger("amount"));
    });
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    getBillingInfo();
  }
}

package com.ibm.microservice.backend.communication;

import com.ibm.microservices.Address;
import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.eventbus.EventBus;
import io.vertx.core.eventbus.MessageConsumer;
import io.vertx.core.json.JsonObject;

public class InventoryVerticle extends AbstractVerticle {
  private void productInfo() {
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> consumer = eventBus.consumer(Address.PRODUCT_INFO);
    //list for message
    consumer.handler(message -> {
      System.out.println(InventoryVerticle.class.getName() + "  -  " + message.body());
    });
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);

    EventBus eventBus = vertx.eventBus();
    MessageConsumer<JsonObject> consumer = eventBus.consumer(Address.IS_STOCK_AVAILABLE);
    //list for message
    consumer.handler(message -> {
      System.out.println(InventoryVerticle.class.getName() + "  -  " + message.body());
      String productName = message.body().getString("name");
      if (productName.equals("tv")) {
        message.reply("Stock Available");
      } else {
        message.reply("Out of Stock");
      }
    });

  }
}
package com.ibm.microservice.web.jdbc;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpMethod;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.RoutingContext;
import io.vertx.ext.web.handler.BodyHandler;

public class ProductRestVerticle extends AbstractVerticle {
  private ProductService productService;

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start();
    productService = new ProductService(vertx);
    //1-connection-success-create tables-start web server
    productService.createTable().compose(v -> {
      //After inserting data : start web part
      Router router = Router.router(vertx);

      //Middlewares (filters) : Which are executed before handling requests

      //this middleware called for any type of request and any type of url
      router.route().handler(rc -> {
        System.out.println(rc.request().method() + " " + rc.request().path());
        rc.next();
      });
      //i want middleware sepecific to that url
      router.route(HttpMethod.GET, "/api/products").handler(rc -> {
        System.out.println("Products api called");
        rc.next();
      });
      //Builtin middlewares: BodyHandler is json seralizer which serialize the incoming json
      //payload into JsonObject
      router.route().handler(BodyHandler.create());

      //Rest apis
      //Get all the products from the database
      router.get("/api/products").handler(this::handleGetProducts);
      //create new product
      router.post("/api/products").handler(this::handleAddProducts);

      return vertx.createHttpServer().requestHandler(router).listen(8080);
    }).<Void>mapEmpty().onComplete(startPromise);
  }

//  <--Todo - ->
  private void handleAddProducts(RoutingContext routingContext) {

  }

  private void handleGetProducts(RoutingContext routingContext) {
    productService.findAllProducts(asyncResult -> {
      if (asyncResult.succeeded()) {
        routingContext.response()
          .setStatusCode(200)
          .putHeader("content-type", "application/json")
          .end(asyncResult.result());
      }
    });
  }
}
package com.ibm.microservices;

import io.vertx.core.Promise;
import io.vertx.reactivex.core.AbstractVerticle;

public class MainAppVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    vertx.rxDeployVerticle("com.ibm.microservice.web.jdbc.ProductRestVerticle").subscribe(r -> {
      System.out.println("ProductRestVerticle " + r + "deployed");
    }, err -> {
      System.out.println("ProductRestVerticle not deployed" + err.getMessage());
    });
    vertx.rxDeployVerticle("com.ibm.microservice.rest.communication.ProductGateWayVerticle").subscribe(r -> {
      System.out.println("ProductGateWayVerticle " + r + "deployed");
    }, err -> {
      System.out.println("ProductGateWayVerticle not deployed" + err.getMessage());
    });
    vertx.rxDeployVerticle("com.ibm.microservice.backend.communication.BillingVerticle").subscribe(r -> {
      System.out.println("BillingVerticle " + r + " deployed");
    }, err -> {
      System.out.println("BillingVerticle not deployed" + err.getMessage());
    });
    vertx.rxDeployVerticle("com.ibm.microservice.backend.communication.InventoryVerticle").subscribe(r -> {
      System.out.println("InventoryVerticle " + r + " deployed");
    }, err -> {
      System.out.println("InventoryVerticle not deployed" + err.getMessage());
    });
  }

}
..............................................................................................
		Threading Models - Non blocking(event loop threads) /Worker pool threads
.............................................................................................

.............................................................................................
                          Blocking code and Non blocking Code:
..............................................................................................

Vertx has been designed to work with nonblocking.
 non blocking web apps,database,tcp,file system..............

Does vertx support blocking code and what if i write blocking code ?

Yes! blocking code, what if i write blocking inside verticles.

Use case : 

You are building vertx application, vertx application need to talk to hibernate/jpa layer.
Vertx is non blocking but hibernate blocking.

if you write blocking inside non blocking vertx will throw error, but how to bridge blocking with non-blocking.
	

Blocking code

-Thread.sleep
-long running task
-legacy file io
-legacy network 
-database 
-external api


 Any blocking code can't be executed inside event loop thread.
 Any blocking code must be executed in a separte threads - Worker pool threads.
 Worker pool threads are used for running long running blocking code.

There are many ways.

how to process blocking code

1.Change the verticle thread from event loop thread to worker pool thread
  These verticle are called worker verticles
2.via an blocking apis provided by vertx.
		


Threading Blocking timeout:

Generally we should not block the event loop thread for long time.
How long? 2000ms - default blocking timeout.
if the code blocks beyond 2000ms, 

-it will give warining
-if it beyond warining, it will throw execption.


package com.cts.vertx.microservice.blocking;

import io.vertx.core.Vertx;

public class BlockTheVertilcle {
  public static void main(String[] args) {
    Vertx vertx = Vertx.vertx();
    vertx.deployVerticle(new BlockingVerticle());
  }
}

package com.cts.vertx.microservice.blocking;

import io.vertx.core.AbstractVerticle;

public class BlockingVerticle extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    System.out.println(Thread.currentThread().getName());
    Thread.sleep(10000);
    System.out.println("Sleep over");
  }
}

Aug 27, 2021 4:48:45 PM io.vertx.core.impl.BlockedThreadChecker
WARNING: Thread Thread[vert.x-eventloop-thread-0,5,main] has been blocked for 2612 ms, time limit is 2000 ms
Aug 27, 2021 4:48:46 PM io.vertx.core.impl.BlockedThreadChecker
WARNING: Thread Thread[vert.x-eventloop-thread-0,5,main] has been blocked for 3612 ms, time limit is 2000 ms
Aug 27, 2021 4:48:47 PM io.vertx.core.impl.BlockedThreadChecker
WARNING: Thread Thread[vert.x-eventloop-thread-0,5,main] has been blocked for 4613 ms, time limit is 2000 ms
Aug 27, 2021 4:48:48 PM io.vertx.core.impl.BlockedThreadChecker
WARNING: Thread Thread[vert.x-eventloop-thread-0,5,main] has been blocked for 5614 ms, time limit is 2000 ms
io.vertx.core.VertxException: Thread blocked
	at java.base@11.0.11/java.lang.Thread.sleep(Native Method)
	at app//com.cts.vertx.microservice.blocking.BlockingVerticle.start(BlockingVerticle.java:10)
	at app//io.vertx.core.AbstractVerticle.start(AbstractVerticle.java:106)
	at app//io.vertx.core.impl.DeploymentManager.lambda$doDeploy$5(DeploymentManager.java:196)
	at app//io.vertx.core.impl.DeploymentManager$$Lambda$77/0x0000000800178840.handle(Unknown Source)
	at app//io.vertx.core.impl.AbstractContext.dispatch(AbstractContext.java:96)
	at app//io.vertx.core.impl.AbstractContext.dispatch(AbstractContext.java:59)
	at app//io.vertx.core.impl.EventLoopContext.lambda$runOnContext$0(EventLoopContext.java:37)
	at app//io.vertx.core.impl.EventLoopContext$$Lambda$78/0x0000000800179440.run(Unknown Source)
	at app//io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164)
	at app//io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472)
	at app//io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500)
	at app//io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)
	at app//io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at app//io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.base@11.0.11/java.lang.Thread.run(Thread.java:834)


..........................................................................................
	What if i want to write blocking code , i need to handle smothly
.........................................................................................

i need to run all blocking code in a separate of thread of execution.

Types of Threads

1.Event loop threads
    -Used only for running non blocking operations
2.Worker pool threads
    -Used to run blocking operations.


Types of Verticle:

1.standard Verticle
   Verticles are normal , executed by event loop thread
2.Woker verticles
   Verticles are special,executed by a separate thread of execution called "Worker poll threads".

How to write worker verticle?

DeployementOptions:
 Object used to configure the runtime parameter of a verticle

 DeploymentOptions options = new DeploymentOptions().setWorker(true);
    vertx.deployVerticle(new WorkerVerticle(), options);

VertxOptions:
  Object used to configure the vertx engine
 like workerpool thread size....

package com.ibm.microservice.blocking;

import io.vertx.core.DeploymentOptions;
import io.vertx.core.Vertx;
import io.vertx.core.VertxOptions;

public class WorkerVerticleMain {
  public static void main(String[] args) {
    VertxOptions vertxOptions = new VertxOptions().setWorkerPoolSize(20);
    Vertx vertx = Vertx.vertx(vertxOptions);
    DeploymentOptions options = new DeploymentOptions().setWorker(true);
    for (int i = 0; i < 50; i++)
      vertx.deployVerticle(new BlockingCodeVerticle(), options);

  }
}
............................................................................................
			What if i want to write blocking inside non blocking context
.....................................................................................
.............................................................................................
	    How to write blocking code and non blocking in the same verticle
.............................................................................................

Incase i have 2 methods are blocking methods and 3 methods are non blocking methods in a single verticle?


2 methods must be handled by work pool threads
3 methods must be handled by event loop threads.

vertx.executeBlocking(blockingcode,grabblocking result);


package com.ibm.microservice.blocking;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.ext.web.Router;

public class ExecuteBlockingVerticle extends AbstractVerticle {
  private GreeterService greeterService = new GreeterService();

  private void runBlocking() {
    vertx.executeBlocking(blockingHandler -> {
      System.out.println("Blocking Code Runs in -->" + Thread.currentThread().getName());
      //calls blocking api
      try {
        String result = greeterService.getMessage();
        blockingHandler.complete(result);
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
    }, ar -> {
      System.out.println("Nonblocking Code Runs in -->" + Thread.currentThread().getName());
      if (ar.succeeded()) {
        System.out.println(ar.result());
      }
    });
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    //Rest service talks to blocking api , then how to handle it
    Router router = Router.router(vertx);

    //hanlder method is only for non blocking code
    //router.get("/api/block").handler();
    router.get("/api/block").blockingHandler(rc -> {
      try {
        String result = greeterService.getMessage();
        rc.response().setStatusCode(200).end(result);
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
    });

    vertx.createHttpServer().requestHandler(router).listen(3000, server -> {
      System.out.println("Server is running " + server.result().actualPort());
    });

  }
}
.............................................................................................
				Micro services -External  Configuration
..............................................................................................

...........................................................................................
				Distributed Configuration
..........................................................................................
Vertx Configuration :Distributed Configuration:
.........................

How to configure Vertx application:

Vert.x Config
  This component provides an extensible way to configure Vert.x applications.


Configuration Stores(Storage):
..............................

Physical storage:

1.files
2.directories -ldap....
3.HTTP Servers - a separate HTTP server.
4.Redis
5.System Properties
6.environment properties
7.In memory Store: Application memory

Configuration representation inisde vertx is json object.

Storage file formats:
1.yaml
2.json
3.properties
......

Verticle:
 -can read config  data from the Vertx Context Object / DeploymentOptions
 -can read config data  from the file via command line args
 -can read from any storage via Vertx-Config module objects like ConfigReteriver.

app/src/main/resources/conf/config.json

{
  "http.port": 3001,
  "message": "Hello,Config"
}



package com.ibm.microservices.config;

import io.vertx.config.ConfigRetriever;
import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.web.Router;

public class ApplicationConfigVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    JsonObject conf = config();
    Router router = Router.router(vertx);
    router.get("/api/config").handler(rc -> {
      rc.response().setStatusCode(200).putHeader("content-type", "application/json").end(conf.encodePrettily());
    });
    vertx.createHttpServer().requestHandler(router).listen(conf.getInteger("http.port",3000));
  }
}

package com.ibm.microservices.config;

import io.vertx.config.ConfigRetriever;
import io.vertx.config.ConfigRetrieverOptions;
import io.vertx.config.ConfigStoreOptions;
import io.vertx.core.DeploymentOptions;
import io.vertx.core.Vertx;
import io.vertx.core.json.JsonObject;

public class ApplicationDeployer {
  private static void inMemoryConfig() {
    Vertx vertx = Vertx.vertx();
    //serverconfig
    JsonObject serverConfig = new JsonObject().put("http.port", 3001);
    //application data configuration
    JsonObject config = new JsonObject().put("message", "Config Data").mergeIn(serverConfig);

    DeploymentOptions options = new DeploymentOptions().setConfig(config);
    vertx.deployVerticle(ApplicationConfigVerticle.class.getName(), options);
  }

  public static void main(String[] args) {

    Vertx vertx = Vertx.vertx();

    //storage configuration
    ConfigStoreOptions options = new ConfigStoreOptions();
    options.setType("file");
    options.setFormat("json");
    options.setConfig(new JsonObject().put("path", "conf/config.json"));

    ConfigRetriever configRetriever = ConfigRetriever.create(vertx,
      new ConfigRetrieverOptions().addStore(options));

    configRetriever.getConfig(config -> {
      if (config.succeeded()) {
        System.out.println("Config is Ready");
        JsonObject configRes = config.result();
        System.out.println(configRes.encodePrettily());
        DeploymentOptions deploymentOptions = new DeploymentOptions().setConfig(configRes);
        vertx.deployVerticle(new ApplicationConfigVerticle(), deploymentOptions);
      } else {
        System.out.println("Config Error : " + config.cause());
      }
    });
  }
}
..............................................................................................
				Service Registry and Discovery
..............................................................................................
What is service?
 Object
What is registry?
 Centeralized database
What is database?
 We store something and later we reterive.

What is discovery?
  Discovery is nothing but "lookup/search" something from the registry.

Why Service Registry?
  "Keeping Global shared information" across the distributed apps(micro service apps)


Service Registry stores "Resources" so that other services in the application can access.


What we can store inside Registry Server in vertx?

 Resources:

Types of Resources(Services):
.............................
The services you can register into registry

HTTP Endpoint -HttpEndPoint.createRecord
Event Bus Service -EventBus.createRecord
Message Source
JDBC Data Source
Redis Data Source
MongoDb Data Source

How to store resources into Service Registry in vertx

1.Record - bag - inside bag you can store any resource-store that record into registry server.

Vertx Resource Storage:

Vertx resources are stored in side registry by packing resouces into a object called "Record".



Implementation:

What you need?

1.Registry server- where you can store all shared resources(httpendpoint,jdbcconnection,eventbus...)

Vertx provides default built in Registry Server:
...............................................
-Key value data structure;
  Map- implementations.

Popular Registry Servers:
.........................
1.eureka server
2.Apache zoo keeper
3.Consule
4.Kubernetes
5.Redis
etc....

Resource--->Record 

Service Discovery Objects:

1.Record
2.Service
3.ServiceDiscovery

Vertx has ServiceDiscovery Instance, which helps to publish / un publish ,and discover
services 


Publishing HTTP End Point into Registry, where other verticles can consume that.


Steps:

1.create Record

2.wrap the resources into Record

3.Publish it

4.Get Record

5.Get Reference from the Record

6.Unpublish it if you dont need

7.Use the Resource(service)


package com.ibm.microservice.rest;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.ext.web.Router;

public class GreeterRestVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    Router router = Router.router(vertx);

    router.get("/api/hello").handler(rc -> {
      rc.response().end("Hello,Service Discovery and Registry");
    });
    vertx.createHttpServer().requestHandler(router).listen(3000);
  }
}

package com.ibm.microservice.discovery;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.client.WebClient;
import io.vertx.servicediscovery.ServiceDiscovery;
import io.vertx.servicediscovery.ServiceDiscoveryOptions;
import io.vertx.servicediscovery.types.HttpEndpoint;

public class ConsumerVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    //Service Communication via Service Discovery
    ServiceDiscoveryOptions discoveryOptions = new ServiceDiscoveryOptions();
    //enable discovery server : apache zoo keeper
    discoveryOptions.setBackendConfiguration(new JsonObject()
      .put("connection", "127.0.0.1:2181")
      .put("ephemeral", true)
      .put("guaranteed", true)
      .put("basePath", "/services/my-backend")
    );
    ServiceDiscovery discovery = ServiceDiscovery.create(vertx, discoveryOptions);

    Router router = Router.router(vertx);

    router.get("/api/greet").handler(rc -> {
      //Communicate Service Registry and get Record,Get Reference.
      HttpEndpoint.getWebClient(discovery, new JsonObject().put("name", "greeterApiRecord"), ar -> {
        //Get Reference from the Record
        WebClient webClient = ar.result();
        //do your job with Resource
        webClient.get("/api/hello").send(result -> {
          System.out.println("Response is ready!");
          rc.response().end(result.result().bodyAsString());
        });
        rc.response().endHandler(ar1 -> {
          //remove /release discovery record
          ServiceDiscovery.releaseServiceObject(discovery, webClient);
        });
      });

    });
    vertx.createHttpServer().requestHandler(router).listen(8080);


  }
}

package com.ibm.microservice.discovery;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonObject;
import io.vertx.servicediscovery.Record;
import io.vertx.servicediscovery.ServiceDiscovery;
import io.vertx.servicediscovery.ServiceDiscoveryOptions;
import io.vertx.servicediscovery.types.HttpEndpoint;

public class PublisherVerticle extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);

    //Service Registry Server configuration
    ServiceDiscoveryOptions discoveryOptions = new ServiceDiscoveryOptions();
    discoveryOptions.setBackendConfiguration(new JsonObject()
      .put("connection", "127.0.0.1:2181")
      .put("ephemeral", true)
      .put("guaranteed", true)
      .put("basePath", "/services/my-backend")
    );
    //Service Registry instance
    ServiceDiscovery discovery = ServiceDiscovery.create(vertx, discoveryOptions);
    //Record Creation : RecordType - RestApi
    Record httpEndPointRecord = HttpEndpoint.createRecord("greeterApiRecord", "localhost", 3000, "/api/hello");
    //Publish the Record
    discovery.publish(httpEndPointRecord, ar -> {
      if (ar.succeeded()) {
        System.out.println("Successfully published >>>>" + ar.result().toJson());
      } else {
        System.out.println(" Not Published " + ar.cause());
      }
    });
  }
}
package com.ibm.micro_servicediscovery;

import com.ibm.microservice.discovery.ConsumerVerticle;
import com.ibm.microservice.discovery.PublisherVerticle;
import com.ibm.microservice.rest.GreeterRestVerticle;
import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;

public class MainVerticle extends AbstractVerticle {

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
      vertx.deployVerticle(new GreeterRestVerticle());
      vertx.deployVerticle(new PublisherVerticle());
      vertx.deployVerticle(new ConsumerVerticle());
  }
}
..............................................................................................
					Failure Management
..............................................................................................

Two failures
1.slow calls - performance
2.exceptions

if my service is too slow , then what should i do
     -TimeoutException
if my service is throwing exception, then what should i do
     -ServerException,bizException.

How to handle exceptions and how to treat exceptions?
try {
  risky code
}
catch(){
 // treating exception
}

We have patterns to handle exceptions in more declarative way :Reslience Design patterns

Vert.x Provides circuit Breaker is an implementation of Circuit Breaker pattern.

It keeps tracks of number of failures and opens the circuit when a threshold is reached.
optionally fallback is given.

States CB:

1.closed
   -Application is working well
2.open
  -Application is failing
3.Half Open
  -Application is recovering from failures


if cb in open state
 What to do? or how to react for failures.

When cb can open?

 if max failures reached
 if timeout is reached
  

1.Circuit Breaker Configuration.


1.Circuit Breaker Configuration.

CircuitBreaker breaker = CircuitBreaker.create("my-circuit-breaker", vertx,
    new CircuitBreakerOptions()
        .setMaxFailures(5) // number of failure before opening the circuit
        .setTimeout(2000) // consider a failure if the operation does not succeed in time
        .setFallbackOnFailure(true) // do we call the fallback on failure
        .setResetTimeout(10000) // time spent in open state before attempting to re-try
);

.............................................................................................
package com.ibm.microservice.cb;

import io.vertx.circuitbreaker.CircuitBreaker;
import io.vertx.circuitbreaker.CircuitBreakerOptions;
import io.vertx.circuitbreaker.HystrixMetricHandler;
import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.buffer.Buffer;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.client.HttpResponse;
import io.vertx.ext.web.client.WebClient;

public class HelloService extends AbstractVerticle {

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    CircuitBreakerOptions options = new CircuitBreakerOptions();
    options.setMaxFailures(2);// no of failures will be allowed , after that , ciruit will open
    options.setMaxRetries(2);
    options.setTimeout(3000); // consider a failure if the operation does not succeed in time
    options.setFallbackOnFailure(true); // if any failure, should i handle fallback or not
    options.setResetTimeout(5000); // time spent in open state before attempting to retry.

    CircuitBreaker circuitBreaker = CircuitBreaker
      .create("my-circuit-breaker", vertx, options)
      .openHandler(open -> {
        System.out.println("cb opened");
      }).closeHandler(close -> {
        System.out.println("cb closed");
      }).retryPolicy(retryCount -> {
        System.out.println("Retry value " + retryCount);
        return retryCount * 100L;
      });

    Router router = Router.router(vertx);
    router.get("/").handler(rc -> {
      circuitBreaker.executeWithFallback(future -> {
        //risky code
        WebClient client = WebClient.create(vertx);
        client.get(3000, "localhost", "/").send(ar -> {
          // Obtain response
          HttpResponse<Buffer> response = ar.result();
          if (response.statusCode() != 200) {
            future.fail("HTTP error");
          } else {
            future.complete(response.bodyAsString());
          }
        });
      }, v -> {
        // Executed when the circuit is opened
        return "Hello, I am fallback";
      }).onComplete(ar -> {
        // Do something with the result
        if (ar.succeeded()) {
          //System.out.println(ar.result());
          rc.response().end(ar.result());
        } else {
          System.out.println(ar.cause());

        }
      });

    });

    // Register the metric handler
    router.get("/hystrix-metrics").handler(HystrixMetricHandler.create(vertx));

    vertx.createHttpServer().requestHandler(router).listen(8080);

  }
}

package com.ibm.microservice.cb;

import io.vertx.core.AbstractVerticle;

public class GreeterService extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    vertx.createHttpServer().requestHandler(r -> {
      //to simulate slow calls : The response will be returned after 5secs
      vertx.setTimer(5000, ar -> {
        r.response().end("I am fine but delayed!");
      });
    }).listen(3000);
  }
}

package com.ibm.microservice.cb;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;

public class MainVerticle extends AbstractVerticle {

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    vertx.deployVerticle(new HelloService());
    vertx.deployVerticle(new GreeterService());
  }
}

........................&&&&&&&&&&&&&&&&&&&&&&&...............................................

				..............................................................................................
			Scalability : How to run multiple instance of the same service
                        (scalablity,loadbalancer,high availablity)
.............................................................................................
package com.ibm.microservices.scalling;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;

public class MainVerticle extends AbstractVerticle {

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    vertx.createHttpServer().requestHandler(req -> {
      req.response()
        .putHeader("content-type", "text/plain")
        .end("Hello!How are you : " + Thread.currentThread().getName() + " " + hashCode());
    }).listen(8888, http -> {
      if (http.succeeded()) {
        startPromise.complete();
        System.out.println("HTTP server started on port 8888");
      } else {
        startPromise.fail(http.cause());
      }
    });
  }
}
package com.ibm.microservices.scalling;

import io.vertx.core.DeploymentOptions;
import io.vertx.core.Vertx;

public class Deployer {
  public static void main(String[] args) {
    Vertx vertx = Vertx.vertx();
    DeploymentOptions options = new DeploymentOptions().setInstances(3);
    vertx.deployVerticle(MainVerticle.class.getName(), options, asyncResult -> {
      System.out.println(asyncResult.result());
    });

  }
}
............................................................................................
				Advanced Scalability and High Availablity
............................................................................................

............................................................................................
			Clustering : How to communicate across vertx Engine
			         (Scallablity + High availablity)
............................................................................................

Distributed Vertx:
.................

As of now we have seen 
 -How to write verticle on single vertx engine
 -How verticles communicate using event bus on single vertx engine


Multi node architecture: Multi vertx engine architecuture:

Vertx Types:
...........

1.Standard Vertx
   -single vertx engine
2.Clustered Vertx
   -distributed vertx engine.

Clustering:

 Grouping  multiple different vertx engines  under one single communication system.
Kind of networking.we are making networking infrastructure among Vertx engins.

How many vertx engines can communcates?

 more vertx engines

Via Cluster Managers and Providers :

 Cluster Providers are third party servers, through vertx can communicates.

Vertx - Clustering:
...................

Clustering , means organization application under one communication channel.

Vertx uses integration/clustering technologies.

Vertx uses hazelcast ClusterManager/provider by default.

Cluster : group of something - group of verticles/vertx instance/jvm

in order to connect vertx apps across processes, we need cordinator 
-Bride softwares

Vertx can work with
-hazelcast
-apache zookeeper
-apache ignite
-apache Infinispan

dependency:

vertx-hazelcast

ClusterManagers

by default, vertx has hazelcast, we dont need to configure by default.


ClusterManagers

by default, vertx has hazelcast, we dont need to configure by default.


How to enable clustering?

In vertx clustering can be enabled in two ways

1.through code

Vertx Configuration;

Types of vertx:
1.standard vertx
2.clusteredVertx

ClusterManager mgr = new HazelcastClusterManager();

VertxOptions options = new VertxOptions().setClusterManager(mgr);

Vertx.clusteredVertx(options, res -> {
  if (res.succeeded()) {
    Vertx vertx = res.result();
    //deployment
  } else {
    // failed!
  }
});

Configuring cluster manager:

Vertx provides default-cluster.xml which is packaged inside cluster jar.

if you want to override you can override cluster.xml file

How to enable cluster feature?

java -jar target/app.jar -cp . -cluster

vertx run verticle -cp . -cluster
..............................................................................................
				
1.Clustering
   
   We can run multiple vertx applications and each application can communicate each other 
via centeralized cluter channel software(hazelcast,zookeeper,apache ignite).

in order to setup cluster on vertx engine
1.we have to enable via Vertx.clusteredVertx Method.


package com.ibm.microservices.scalling;

import io.vertx.core.*;
import io.vertx.core.eventbus.EventBus;
import io.vertx.core.eventbus.MessageConsumer;
import io.vertx.core.spi.cluster.ClusterManager;
import io.vertx.spi.cluster.hazelcast.HazelcastClusterManager;

import java.lang.management.ManagementFactory;
import java.lang.management.RuntimeMXBean;

public class ConsumerVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    //To which cluster software to connect
    ClusterManager mgr = new HazelcastClusterManager();
    //VertxOptions
    VertxOptions options = new VertxOptions()
      .setClusterManager(mgr)
      .setHAEnabled(true)
      .setHAGroup("g1");
    //create clusteredVertx Engine

    Vertx.clusteredVertx(options, cluster -> {
      if (cluster.succeeded()) {
        //deploying the verticle in cluster
        DeploymentOptions deploymentOptions = new DeploymentOptions();
        cluster.result().deployVerticle("com.ibm.microservices.scalling.ConsumerVerticle", deploymentOptions, res -> {
          if (res.succeeded()) {
            System.out.println("Deployment id is: " + res.result());
          } else {
            System.out.println("Deployment failed!");
          }
        });
      } else {
        System.out.println("Cluster up failed: " + cluster.cause());
      }
    });
  }

  private void consumeNews() {
    EventBus eventBus = vertx.eventBus();
    //Declare Consumer
    MessageConsumer<String> consumer = eventBus.consumer("news.in.covid");
    //handle/process the message/news
    consumer.handler(news -> {
      RuntimeMXBean runtimeBean = ManagementFactory.getRuntimeMXBean();
      String jvmName = runtimeBean.getName();
      System.out.println("Node  Name = " + jvmName);
      long pid = Long.valueOf(jvmName.split("@")[0]);
      System.out.println("PID  = " + pid + " Thread = " + Thread.currentThread().getName());
      System.out.println("News 7's Today News : " + news.body());
    });
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    consumeNews();
  }
}
..............................................................................................
package com.ibm.microservices.scalling;

import io.vertx.core.*;
import io.vertx.core.spi.cluster.ClusterManager;
import io.vertx.spi.cluster.hazelcast.HazelcastClusterManager;

import java.lang.management.ManagementFactory;
import java.lang.management.RuntimeMXBean;

public class PublisherVerticle extends AbstractVerticle {

  public static void main(String[] args) {
    ClusterManager mgr = new HazelcastClusterManager();

    VertxOptions options = new VertxOptions()
      .setClusterManager(mgr)
      .setHAEnabled(true)
      .setHAGroup("g1");

    Vertx.clusteredVertx(options, vertxAsyncResult -> {
      if (vertxAsyncResult.succeeded()) {
        //deploy verticles on cluster env.
        DeploymentOptions deploymentOptions = new DeploymentOptions()
          .setInstances(2).setHa(true);
        vertxAsyncResult.result().deployVerticle("com.ibm.microservices.scalling.PublisherVerticle", deploymentOptions, res -> {
          if (res.succeeded()) {
            System.out.println("Deployment id is: " + res.result());
          } else {
            System.out.println("Deployment failed!");
          }
        });

      } else {
        System.out.println("Cluster up failed: " + vertxAsyncResult.cause());
      }
    });
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    RuntimeMXBean runtimeBean = ManagementFactory.getRuntimeMXBean();
    String jvmName = runtimeBean.getName();
    //processid
    long pid = Long.valueOf(jvmName.split("@")[0]);
    vertx.setPeriodic(5000, ar -> {
      System.out.println("PID  = " + pid + " Thread = " + Thread.currentThread().getName());
      //publish message
      String news = "Last 24 hrs, 50000 covid patients in India" + " From  " + jvmName;
      vertx.eventBus().publish("news.in.covid", news);
    });
  }
}
..............................................................................................
					Service Proxy
..............................................................................................


Layer:

1.Verticle
   -RESTAPI
   -WithoutRestAPI

2.Service Proxy

Code developer writes

  ServiceInterface

  ServiceImplementation


Code generatored by vertx : Stub classes
  exposes /sends service objects over event bus

codegen: compiler plugin

<dependency>
 <groupId>io.vertx</groupId>
 <artifactId>vertx-codegen</artifactId>
 <version>4.1.4</version>
 <scope>provided</scope>
</dependency>